
\section{Tendermint}
\label{sec:tendermint}

\newcommand\Propose{\mathsf{PROPOSAL}}
\newcommand\PrePrepare{\mathsf{INIT}}
\newcommand\Prepare{\mathsf{PREVOTE}}
\newcommand\Commit{\mathsf{PRECOMMIT}}
\newcommand\Decision{\mathsf{DECISION}}

\newcommand\ViewChange{\mathsf{VC}}
\newcommand\ViewChangeAck{\mathsf{VC\mbox{-}ACK}}
\newcommand\NewPrePrepare{\mathsf{VC\mbox{-}INIT}}
\newcommand\coord{\mathsf{proposer}}

\newcommand\initState{init}
\newcommand\preVoted{pre\mbox{-}voted}
\newcommand\preCommitted{pre\mbox{-}committed}

\newcommand\timeoutPropose{timeoutPropose}
\newcommand\timeoutPrevote{timeoutPrevote}
\newcommand\timeoutCommit{timeoutPreCommit}

\begin{algorithm}[htb!]
\def\baselinestretch{1}
\scriptsize\raggedright
\begin{algorithmic}[1]
\SHORTSPACE
\INIT{}
  \STATE $v_p := v \in V$ \COMMENT{value considered for consensus} 
  \STATE $round_p := 0$   \COMMENT{current round number} 
  \STATE $vote_p := nill$ \COMMENT{locked value}
  \STATE $ts_p := -1$ \COMMENT{ if $ts_p \ge 0$, it represents round in which $vote_p$ has been locked}
  \STATE $proof_p := \emptyset$ \COMMENT{set of signed messages as a proof that $vote_p$ has been locked in round $ts_p$}
  \STATE $state_p \in \set{\initState=0,\preVoted=1,\preCommitted=2}$, initially $\initState$
  \STATE $decision_p = nill$
  
\ENDINIT

\SPACE
\UPON{start}
  \STATE $StartRound(0)$
\ENDUPON

\SPACE
\FUNCTION{$StartRound(round)$} \label{line:tab:startRound}
\STATE $round_p \assign round$
\STATE $state_p \assign init$
\IF{$\coord(round_p) = p$} 
\IF{$ts_p \ge 0$}
\STATE $proposal \assign vote_p$
\ELSE 
\STATE $proposal \assign v_p$
\ENDIF	  	  
\STATE \PBroadcast\ $\li{\Propose,round_p,proposal,ts_p, proof_p}$ to all \label{line:tab:send-propose}
\ENDIF
\STATE \textbf{after} $\timeoutPropose$ execute $OnTimeoutPropose(round_p)$
\ENDFUNCTION


\SPACE
\UPON{receiving $\li{\Propose,round_p, vote, ts, proof}$ \From\ $\coord(round_p)$ \With\ $state_p = \initState$} \label{line:tab:recvInit}
 \IF{$isValidProposal(vote,ts,proof)$}
   \STATE \PBroadcast \ $\li{\Prepare,round_p,vote}$ to all \label{line:tab:send-echo}
   \STATE $state_p \assign \preVoted$ \label{line:tab:setStateToEchoed}
   \IF{$vote \neq vote_p \wedge ts > ts_p$}
     \STATE $vote_p \assign nill$
     \STATE $ts_p \assign -1$
    \ENDIF
 \ENDIF
\ENDUPON

\SPACE
\FUNCTION{$OnTimeoutPropose(round)$} \label{line:tab:onTimeoutPropose}
\IF{$round = round_p \wedge state_p = \initState$}
\STATE \PBroadcast \ $\li{\Prepare,round_p,nill}$ to all 
\STATE $state_p \assign \preVoted$  
\ENDIF	
\ENDFUNCTION

\SPACE
\UPON{receiving $\li{\Prepare,round,vote}$  \From\ $2f+1$ processes \With\
($round = round_p \wedge state_p \le \preVoted$) or $round > round_p$} \label{line:tab:recvEcho}
 \STATE $vote_p \assign vote$   \label{line:tab:setV}
 \IF{$vote = nill$}
  \STATE $ts_p \assign -1$
 \ELSE 
 	\STATE $ts_p \assign round$ \label{line:tab:setTs}
 \ENDIF
 \STATE $round_p \assign round$
 \STATE \PBroadcast \ $\li{\Commit,round_p,vote_p}$ to all \label{line:tab:send-commit}
 \STATE $state_p \assign \preCommitted$ \label{line:tab:setStateToCommitted}
 \STATE $proof_p \assign$ \{set of received signed messages\}
\ENDUPON

\SPACE
\UPON{receiving $\li{\Prepare,round_p,*}$  \From\ $2f+1$ processes \With\
	$state_p = \preVoted$ \COMMENT{a sign * denotes any value}} 
\STATE \textbf{after} $\timeoutPrevote$ execute $OnTimeoutPrevote(round_p)$
\ENDUPON

\SPACE
\FUNCTION{$OnTimeoutPrevote(round)$} \label{line:tab:onTimeoutPrevote}
\IF{$round = round_p \wedge state_p = \preVoted$}
\STATE \PBroadcast \ $\li{\Commit,round_p,nill}$ to all 
\STATE $state_p \assign \preCommitted$  
\ENDIF	
\ENDFUNCTION

\SPACE
\UPON{receiving ($\li{\Commit,round,vote}$ \From\ $2f+1$ processes \With\ $round \ge round_p$} \label{line:tab:recvCommit}
  \IF{$vote \neq nill \wedge decision_p = nill$}
   \STATE $decision_p \assign vote$ \label{line:tab:setStateToDecided}
  \ENDIF
  \STATE $StartRound(round+1)$	
\ENDUPON
 
\SPACE
\UPON{receiving $\li{\Commit,round_p,*}$  \From\ $2f+1$ processes \With\
	$state_p = \preCommitted$ \COMMENT{a sign * denotes any value}} 
\STATE \textbf{after} $\timeoutPreCommit$ execute $OnTimeoutPreCommit(round_p)$
\ENDUPON 

\SPACE
\FUNCTION{$OnTimeoutPreCommit(round)$} \label{line:tab:onTimeoutCommit}
\IF{$round = round_p \wedge state_p = \preCommitted$}
\STATE $StartRound(round+1)$
\ENDIF	
\ENDFUNCTION

\SPACE
\UPON{receiving message \textbf{with} $round > round_p$ \From\ $f+1$ processes} \label{line:tab:skipViews}
\STATE $StartRound(round)$
\ENDUPON

\SPACE
\FUNCTION{$isValidProposal(vote, ts, proof)$} \label{line:tab:isValidProposal}
\IF{$vote = vote_p \vee ts_p = -1$}
  \STATE \textbf{return} true
\ENDIF
\IF{$ts > ts_p$ \textbf{and} $proof$ confirms that $vote$ was locked at round $ts$} 
  \STATE \textbf{return} true
\ENDIF
\STATE \textbf{return} false
\ENDFUNCTION

\end{algorithmic}
\caption{Tendermint consensus algorithm}
\label{alg:tendermint}
\end{algorithm}


\textbf{NOTE: The algorithm description and the corresponding proofs refer to the previous version of the pseudocode and need to be updated!}

In this section we present a new Byzantine consensus algorithm called Tendermint\footnote{https://github.com/tendermint/tendermint} 
(see Algorithm~\ref{alg:tendermint}). 
The algorithm requires $n > 3f$ processes to tolerate at most $f$ Byzantine faults, but for simplicity we present the algorithm for the case $n = 3f + 1$. The rounds of Algorithm~\ref{alg:tendermint} are executed atomically. 

It shares the basic mechanisms called locking and unlocking of a value with DSL algorithm for authenticated faults (Algorithm 2 from \cite{DLS88:jacm}), but algorithm structure and implementation of these mechanisms is different in Tendermint. 

The algorithm proceeds in a sequence of rounds, where each round has a dedicated coordinator (sometimes also called a proposer), that is determined via a deterministic function $\coord$, a function of the agreed previous global state. A correct process moves to a higher round either if a round timeout has expired (line 37) or if process receives a message from a correct process that is in a higher round (lines 26-27). We assume that messages from higher rounds are internally stored by the messaging layer (in case the rule from line 26 is satisfied, round transition is triggered), and then delivered to a process when it enters the corresponding round. Messages from lower rounds are dropped.

The locking mechanism has a role in ensuring the agreement property of the consensus, while the unlocking mechanism is related to the termination property. Locking guarantees that two correct processes can lock only a single value in some round $r$. Note that they can, however, potentially lock different values in distinct rounds. A correct process can have only a single value locked at a particular point of algorithm execution. In Algorithm~\ref{alg:tendermint}, a correct process $p$ locks a value $v$ in round $r$ by setting a variable $vote_p$ to $v$ and a variable $ts_p$ to $r$. The unlocking mechanism ensures that eventually (after GST) all correct processes can have only single value $v$ locked. This helps to bring the system into univalent configuration~\cite{FLP85:jacm}. In Algorithm~\ref{alg:tendermint}, a process $p$ unlocks a value by setting $vote_p$ to $null$ and $ts_p$ to -1. Initially, all correct processes do not lock any value.

Each round is composed of three phases (steps) called propose, prepare and commit. A round starts with a propose phase (lines 28-37) in which a dedicated proposer sends its proposal to all processes. If a proposer $p$ has locked some value $v$, then it proposes $v$; otherwise it proposes its initial value $v_p$ (lines 32-35). In addition to the proposed value, the $\Propose$ message also contains $ts$ and a proof of locking a value (in case the proposal is equal to the locked value), that consists of a set of signed messages received by the process $p$ in the round in which the value was locked. 

When a correct process receives a proposal message from a designated proposer (lines 11-17), it checks if the message is a valid proposal (lines 41-46). A correct process $p$ considers a proposal as valid if (i) the proposal value is equal to the locked value of the process ($vote_p$) or if $p$ hasn't locked any value ($ts_p = -1$), or (ii) if the proposal has a different value but from a higher round and with a valid proof of locking. If a process accepts a proposal as valid, it enters the prepare phase by sending the proposed value in a new $\Prepare$ message to all processes. In case (ii), as there is a valid locked value in a higher round, the process unlocks its value.  

When a correct process $p$ receives $2f+1$ $\Prepare$ messages for the same value $v$, then the process locks a value $v$ (and saves a proof of locking into variable $proof_p$) and enters commit step by sending $v$ in a $\Commit$   message (lines 18-23). When a process receives $2f+1$ $\Commit$   messages for some value $v$, it decides value $v$. 

Note that the algorithm relies on the $state$ variable to prevent correct processes from sending more than one $\Prepare$ and $\Commit$ messages in a single round $r$. For simplicity, the currently presented version of the algorithm does not provide a termination condition, i.e., processes continue round execution even after deciding. We also assume that round timeout is being incremented in each round so that eventually all correct processes are able to receive all messages from correct processes in a round before the round timeout expires.  
Furthermore, the algorithm solves only the single instance consensus problem. The multi-instance version of Tendermint will be addressed in the next version of this document. The authors conjecture that it will be straightforward to modify Algorithm~\ref{alg:tendermint} to provide multi-instance capability with the following modifications: (i) adding a consensus instance number in each message, (ii) having per-instance algorithm state variables and (iii) adding logic for starting the next consensus instance.

\subsection{Proof of correctness (sketch)}

\textbf{Agreement} Let assume that a first correct process that decides is $p$ and that $p$ decides value $v$ in round $r$. As $p$ decided $v$ this means that $p$ received at least $2f+1$ $\Commit$  messages with value $v$ in the round $r$ (line 24). This means that at least $f+1$ correct processes have locked value $v$ in round $r$ and have the variable $vote$ set to $v$ and $ts$ variable set to $r$. As correct processes can send only a single $\Commit$  message per round, and there are at most $f$ faulty processes, then no correct process can receive $2f+1$ $\Commit$  messages in the round $r$ for some other value $v' \neq v$. Therefore, no correct process can decide a different value than $v$ in the round $r$. 

Now lets consider the smallest round $r' > r$ in which correct process $q$ locks some value $v'$. As $q$ locks value $v'$ this means that $q$ has received at least $2f+1$ $\Prepare$ messages equal to $v'$ in the round $r'$. Therefore, at least $f+1$ correct processes has sent $v'$ in $\Prepare$ message in the round $r'$. As $f+1$ correct processes have $q'$ locked value $v$ in the round $r$, this means that one of those processes sent a $PROPOSE$ message with value $v'$ in the round $r'$. According to the function $isValidProposal$, $q'$ received a valid proof of locking for value $v'$. This is in contradiction with the assumption that $r'$ is the smallest round in which some correct process locks some value (TODO: improve this part, it is not very precise as it could be reasoned that a Byzantine process could create correct proof of locking for some value $v'$ and round greater than $r'$ which can be proved impossible with the similar reasoning). As no correct process can lock any value different from $v$ in rounds $r' > r$, then no correct process can decide value different from $v$. 

\textbf{Termination} 

The Algorithm~\ref{alg:tendermint} does not terminate as the following scenario is possible: we consider rounds after GST, starting from round $r$ and at round $r$ a correct process $p$ is the only process that locks some value $v$ among the correct processes ($0 \le ts_p \le r$). Assume that no correct process has decided. Let assume that $p$ would coordinate the round $r'>r$. In rounds smaller than $r'$, $p$ will reject any proposal from correct processes if it's not equal to $v$ (which is possible if all correct processes have different initial values), so it will not send $PREPARE$ message. As faulty processes could decide not to send any message, no correct processes will be able to lock a value and to decide in those rounds. Now lets assume that in round $r'-1$ some correct process $q$ locks value $v' \neq v$ because a faulty process (together with all correct processes except $p$) sends $\Prepare$ message with $v'$ to $q$. As $q$ locks value $v'$ in a round higher than $r$, $q$ will reject a proposal from $p$ in round $r'$ so if faulty processes stay silent, again no correct processes can decide in that round. This scenario can be repeated also with the rounds $k-1$ and $k$, in which the process $q$ is proposer.

The property that needs to be ensured is the following: after GST, there exists a round such that a proposal from a correct process is accepted by all correct processes. The solution could be adding one more step (lock-release step) at the end of each round where correct processes would send its locked value (together with $ts$ and proof) to all processes, and then a correct process will release the lock upon reception of a proof of locking for a different value from a higher round. We will also need to modify lines 35 and 36 to propose the value with the valid proof of locking from the highest round (if the process is aware of such a value) or the initial value.

            


