# ***This an unfinished draft. Comments are welcome!***

# Light Client Attack Detector

In this specification, we strengthen the light client to be resistant
against so-called light client attacks. In a light client attack, all
the correct Tendermint full nodes agree on the sequence of generated
blocks (no fork), but a set of faulty full nodes attack a light client
by generating (signing) a block that deviates from the block of the
same height at the blockchain. In order to do so, some of these faulty
full nodes must have been validators before and violate
[TMBC-FM-2THIRDS], as otherwise, if [TMBC-FM-2THIRDS] would hold,
[verification](../verification/verification.md] would satisfy
[LCV-SEQ-SAFE.1].

An attack detector (or detector for short) is a mechanism that is used
by the light client [supervisor](../supervisor/supervisor.md) after
[verification](../verification/verification.md] of a new light block
with the primary, to cross-check the newly learned light block with
other peers (secondaries).  It expects as input a light block with some
height *h-root* (that serves as a root of trust, and except during
initialization, has been cross-checked before), and a verification
trace (a sequence of lightblocks) that the primary provided.

In case the detector observes a light client attack, it computes
evidence data that can be used by Tendermint full nodes to isolate a
set of faulty full nodes that are still within the unbonding period,
and report them via ABCI to the application of a Tendermint blockchain
in order to punish faulty nodes.

## Context of this document

The light client verification specification [[verification]] is
designed for the Tendermint failure model (1/3 assumption)
[TMBC-FM-2THIRDS]. It is safe under this assumption, and live
if it can reliably (that is, no message loss, no duplication, and
eventually delivered) and timely communicate with a correct full node. If
this assumption is violated, the light client can be fooled to trust a
light block that was not generated by Tendermint consensus.

This specification, the attack detector, is a "second line of defense",
in case the 1/3 assumption is violated.
Its goal is to detect a light client attack (conflicting light blocks)
and collect
evidence. However, it is impractical to probe all full nodes. At this
time we consider a simple scheme of maintaining an address book of
known full nodes from which a small subset (e.g., 4) are chosen
initially to communicate with. More involved book keeping with
probabilistic guarantees can be considered at later stages of the
project.

The light client maintains a simple address book containing addresses
of full nodes that it can pick as primary and secondaries.  To obtain
a new light block, the light client first does [verification](verification)
with the primary, and then cross-checks the light block (and the trace of
light blocks that led to it) with the
secondaries using this specification.

## Tendermint Consensus and Forks

**TODO:** explain difference between fork concept below that is based
on the existence of blocks, and attacks and main-chain forks that are
based on who receives such blocks.

#### **[TMBC-GENESIS.1]**

Let *Genesis* be the agreed-upon initial block (file).

#### **[TMBC-FUNC.1]**

> **TODO** be more precise. +2/3 of b.NextV = c.Val signed c. For now
> the following will do:

Let b and c be two light blocks
with *b.Header.Height + 1 = c.Header.Height*. We define **signs(b,c)**
    iff `ValidAndVerified(b, c)`

> **TODO** be more precise. +1/3 of b.NextV signed c. For now
> the following will do:

Let *b* and *c* be two light blocks. We define **supports(b,c,t)**
    iff `ValidAndVerified(b, c)` at time *t*

> The following formalizes that *b* was properly generated by
> Tendermint; *b* can be traced back to genesis

#### **[TMBC-SEQ-ROOTED.1]**

Let *b* be a light block.
We define *sequ-rooted(b)* iff for all i, 1 <= i < h = b.Header.Height,
there exist light blocks a(i) s.t.

- *a(1) = Genesis* and
- *a(h) = b* and
- *signs( a(i) , a(i+1) )*.

> The following formalizes that *c* is trusted based on *b* in
> skipping verification. Observe that we do not require here (yet)
> that *b* was properly generated.

#### **[TMBC-SKIP-ROOT.1]**

Let *b* and *c* be light blocks. We define *skip-root(b,c,t)* if at
time t there exists an *h* and a sequence *a(1)*, ... *a(h)* s.t.

- *a(1) = b* and
- *a(h) = c* and
- *supports( a(i), a(i+1), t)*, for all i, *1 <= i < h*.

> **TODO** In the above we might use a sequence of times t(i). Not sure.
> **TODO:** I believe the following definition
> corresponds to **Slashable fork** in
> [forks][tendermintfork]. Please confirm!  
> Observe that sign-skip-match  is even defined if there is a fork on
> the chain.

#### **[TMBC-SIGN-SKIP-MATCH.1]**

Let *a*, *b*, *c*, be light blocks and *t* a time, we define
*sign-skip-match(a,b,c,t) = true* iff

- *sequ-rooted(a)* and
   <!-- - *sequ-rooted(b)* and -->
- *b.Header.Height = c.Header.Height* and
- *skip-root(a,b,t)*
- *skip-root(a,c,t)*

implies *b = c*.

#### **[TMBC-ATTACK.1]**

If there exists three light blocks a, b, and c, with
*sign-skip-match(a,b,c,t) =
false* then we have an *attack*.  
We call *a* a bifurcation block of the fork.  
We say we have **an attack at height** *b.Header.Height* and write
*attack(a,b,c,t)*.

> The lightblock *a* need not be unique, that is, a there may be
> several blocks that satisfy the above requirement for blocks *b* and
> *c*.

[TMBC-ATTACK.1] is a formalization of the violation of the agreement
property based on the result of consensus, that is, the generated
blocks. From then on there are different ways to characterize forks
and attack scenarios. This specification uses the "node-based
characterization of attacks" which focuses on what nodes are
affected. For future reference and discussion we also provide a
"block-based characterization of attacks".

### Node-based characterization of attacks

#### **[TMBC-MC-FORK.1]**

We say there is a (main chain) fork at time *t* if

- there are two correct full nodes *i* and *j* and
- *i* is different from *j* and
- *i* has decided on *a* and
- *j* has decided on *b* and
- there exist *a* such that *attack(a,b,c,t)*.

#### **[TMBC-LC-ATTACK.1]**

We say there is a light client attack at time *t*, if

- there is **no** (main chain) fork and
- there exist nodes that have computed light blocks *b* and *c* and
- there exist *a* such that *attack(a,b,c,t)*.

> In this specification we consider detection of light client
> attacks. Intuitively, the case we consider is that
> light block *b* is the one from the
> blockchain, and some attacker has computed *c* and tries to wrongly
> convince
> the light client that *c* is the block from the chain.

#### **[TMBC-ATTACKERS.1]**

If *attack(a,b,c,t)* then find validators from *a'*
s.t. *attack(a',b,c,t)* and +1/3 of the validators misbehaved

### Block-based characterization of attacks

> **TODO:** fix text or remove section altogether
  
#### **[TMBC-SIGN-UNIQUE.1]**

Let *b* and *c* be  light blocks, we define *sign-unique(b,c) =
true* iff

- *b.Header.Height =  c.Header.Height* and
- *sequ-rooted(b)* and
- *sequ-rooted(c)*

implies *b = c*.

If there exists two light blocks b and c, with *sign-unique(b,c) =
false* then we have a *fork on the chain*.

> The following captures what I believe is called a light client fork
> in our discussions. There is no fork on the chain up to the height
> of block b. However, c is of that height, is different, and passes skipping
> verification  
> Observe that a light client fork is a special case of a slashable
> fork.

#### **[TMBC-LC-FORK.1]**

Let *a*, *b*, *c*, be light blocks and *t* a time. We define
*light-client-fork(a,b,c,t)* iff

- *sign-skip-match(a,b,c,t) = false* and
- *sequ-rooted(b)* and
- *b* is "unique", that is, for all *d*,  *sequ-rooted(d)* and
     *d.Header.Height=b.Header.Height* implies *d = b*

> Finally, let's also define bogus blocks that have no support.
> Observe that bogus is even defined if there is a fork on the chain.
> Also, for the definition it would be sufficient to restrict *a* to
> *a.height < b.height* (which is implied by the definitions which
> unfold until *supports()*.

#### **[TMBC-BOGUS.1]**

Let *b* be a light block and *t* a time. We define *bogus(b,t)* iff

- *sequ-rooted(b) = false* and
- for all *a*, *sequ-rooted(a)* implies *skip-root(a,b,t) = false*
  
> Relation to [fork accountability][accountability]: F1, F2, and F3
> (equivocation, amnesia, back to the past) can lead to a fork on the
> chain and to a light client attack.  
> F4 and F5 (phantom validators, lunatic) cannot lead to a fork on the
> chain but to a light client
> attack if *t+1 < f < 2t+1*.  
> F4 and F5 can also lead to bogus blocks

### Informal Problem statement

There is no sequential specification: the detector only makes sense
in a distributed systems where some nodes misbehave.

We work under the assumption that full nodes and validators are
responsible for detecting attacks on the main chain, and the evidence
reactor takes care of broadcasting evidence to communicate
misbehaving nodes via ABCI to the application, and halt the chain in
case of a fork. The point of this specification is to shield a light
clients against attacks that cannot be detected by full nodes, and
are fully addressed at light clients (and consequently IBC relayers
that use the light client protocols to observe the state of a
blockchain. In order to provide full nodes the incentive to follow
the protocols when communicating with the light client, this
specification also considers the generation of evidence that will
also be processes by the Tendermint blockchain.

#### **[LCD-IP-MODEL.1]**

The detector is designed under the assumption that

- [TMBC-FM-2THIRDS] may be violated
- there is no fork on the main chain.

> As a result some faulty full node launch an attack on a light client.

The following requirements are operational in that they describe how
things should be done, rather than what should be done. However, they
do not constitute temporal logic verification conditions. For those,
see [LCD-DIST-*] below.

The detector is called in the [supervisor](TODO) as follows

```go
Evidences := AttackDetector(root_of_trust, verifiedLS);`
```

where

- `root-of-trust` is a light block that is trusted (that is,
except upon initialization, the primary and the secondaries
agreed on in the past), and
- `verifiedLS` is a lightstore that contains a verification trace that
  starts from a lightblock that can be verified with the
  `root-of-trust` in one step and ends with a lightblock of the height
  requested by the user
- `Evidences` is a list of evidence for misbehavior

#### **[LCD-IP-STATEMENT.1]**

Whenever AttackDetector is called,
the detector should for each secondary do the following

- query the secondary by calling `FetchLightBlock` for height
  *verifiedLS.Latest().Height* remotely.
- in case the returned block *b* is different from verifiedLS.Latest(),
  try to replay the verification trace `verifiedLS` with the secondary
  - in case replaying leads to detection of a light client attack
      (one of the lightblocks differ from the one in verifiedLS with
      the same height), we should return evidence
  - if the secondary cannot provide a verification trace, we have no
      proof for an attack. Block *b* may be bogus. In this case the
      secondary is faulty and it should be replaces.

## Assumptions/Incentives/Environment

It is not in the interest of faulty full nodes to talk to the
detector as long as the  detector is connected to at least one
correct full node. This would only increase the likelihood of
misbehavior being detected. Also we cannot punish them easily
(cheaply). The absence of a response need not be the fault of the full
node.

Correct full nodes have the incentive to respond, because the
detector may help them to understand whether their header is a good
one. We can thus base liveness arguments of the  detector on
the assumptions that correct full nodes reliably talk to the
detector.

### Assumptions

#### **[LCD-A-CorrFull.1]**

At all times there is at least one correct full
node among the primary and the secondaries.

> For this version of the detection we take this assumption. It
> allows us to establish the invariant that the lightblock
> `root-of-trust` is always the one from the blockchain, and we can
> use it as starting point for the evidence computation. Moreover, it
> allows us to establish the invariant at the supervisor that any
> lightblock in the (top-level) lightstore is from the blockchain.  
> In the future we might design a lightclient based on the assumption
> that at least in regular intervals the lightclient is connected to a
> correct full node. This will require the detector to reconsider
> `root-of-trust`, and remove lightblocks from the top-level
> lightstore. 


#### **[LCD-A-RelComm.1]**

Communication between the  detector and a correct full node is
reliable and bounded in time. Reliable communication means that
messages are not lost, not duplicated, and eventually delivered. There
is a (known) end-to-end delay *Delta*, such that if a message is sent
at time *t* then it is received and processed by time *t + Delta*.
This implies that we need a timeout of at least *2 Delta* for remote
procedure calls to ensure that the response of a correct peer arrives
before the timeout expires.


## Definitions

TODO

- A fixed set of full nodes is provided in the configuration upon
     initialization. Initially this set is partitioned into
  - one full node that is the *primary* (singleton set),
  - a set *Secondaries* (of fixed size, e.g., 3),
  - a set *FullNodes*.
- A set *FaultyNodes* of nodes that the light client suspects of being faulty; it is initially empty


#### **[LCD-INV-NODES.1]:**

The detector shall maintain the following invariants:

- *FullNodes \intersect Secondaries = {}*
- *FullNodes \intersect FaultyNodes = {}*
- *Secondaries \intersect FaultyNodes = {}*

and the following transition invariant

- *FullNodes' \union Secondaries' \union FaultyNodes' = FullNodes \union Secondaries \union FaultyNodes*

> The following invariant is very useful for reasoning, and underlies
> many intuition when we

## (Distributed) Problem statement

> As the attack detector from the beginning is there to reduce the
> impact of faulty nodes, and faulty nodes imply that there is a
> distributed system, there is no sequential specification to which
> this distributed problem statement may refer to.



#### **[LCD-DIST-INV-ATTACK.1]**

If the detector returns non-empty evidence, then there is an
attack at height *verifiedLS.Latest()* ([TMBC-ATTACK.1]).

#### **[LCD-DIST-INV-STORE.1]**

If the detector returns empty evidence, then *verifiedLS* contains
only blocks from the blockchain.

#### **[LCD-DIST-BOGUS.1]**

If a secondary reports a bogus lightblock, then the secondary is
replaced. 


> The above property is quite operational ("reports"), but it captures 
> quite closely the requirement. As the
> detector only makes sense in a distributed setting, and does
> not have a sequential specification, less "pure"
> specification are acceptable.


# Protocol (goes here)



### Data Structures

#### **[LCD-DATA-LIGHTSTORE.1]**

Lightblocks and LightStores are
defined in the verification specification
[LCV-DATA-LIGHTBLOCK.1] and [LCV-DATA-LIGHTSTORE.1]. See the [verification specification][verification] for details.

TODO: add those to verification  
In additions to the functions defined in
the [verification specification][verification], the
LightStore exposes the following function

#### **[LCD-FUNC-SUBTRACE.1]:**

```go
func (ls LightStore) Subtrace(from int, to int) LightStore
```

- Expected postcondition
  - returns a lightstore that contains all lightblocks *b* from *ls*
     that satisfy: *from < b.Header.Height <= to*
----

**TODO:** the evidence should go to the supervisor spec

The following data structure is the one that the lightclient submits
to a peer. It is created specifically for that peer
depending on the lightblocks it provided to the lightclient.

#### **[LCD-DATA-EVIDENCE.1]**

```go
type LightClientAttackEvidence struct {
    ConflictingBlock   LightBlock
    CommonHeight       int64
}
```

As the above data is computed for a specific peer, the following
data structure wraps the evidence and adds the peerID.

#### **[LCD-DATA-EVIDENCE-INT.1]**
```go
type InternalEvidence struct {
    Evidence           LightClientAttackEvidence
    Peer               PeerID
}
```


### Inter Process Communication

```go
func FetchLightBlock(peer PeerID, height Height) LightBlock
```

See the [verification specification][verification] for details.



### Auxiliary Functions (Local)

**TODO:** this should also go to the supervisor. Especially replace
primary only happens there.

#### **[LCD-FUNC-REPLACE-PRIMARY.1]:**

```go
Replace_Primary()
```

**TODO:** formalize conditions

- Implementation remark
  - the primary is replaced by a secondary, and lightblocks above
      trusted blocks are removed
  - to maintain a constant size of secondaries, at this point we
      might need to
    - pick a new secondary *nsec*
    - maintain [LCD-INV-TRUSTED-AGREED.1], that is,
      - call `CrossCheck(nsec,lightStore.LatestTrusted()`.
              If it matches we are OK, otherwise
        - we repeat with another full node as new
                   secondary candidate
        - **FUTURE:** try to do fork detection from some possibly old
                   lightblock in store. (Might be the approach for the
                   light node that assumes to be connected to correct
                   full nodes only from time to time)

- Expected precondition
  - *FullNodes* is nonempty

- Expected postcondition
  - *primary* is moved to *FaultyNodes*
  - all lightblocks with height greater than
      lightStore.LatestTrusted().Height are removed from *lightStore*.
  - a secondary *s* is moved from *Secondaries* to primary

> this ensures that *s* agrees on the Last Trusted State

- Error condition
  - if precondition is violated

#### **[LCD-FUNC-REPLACE-SECONDARY.1]:**

```go
Replace_Secondary(addr Address)
```

**TODO:** formalize conditions

- Implementation remark
  - maintain [LCD-INV-TRUSTED-AGREED.1], that is,
    - call `CrossCheck(nsec,lightStore.LatestTrusted()`.
           If it matches we are OK, otherwise
      - we might just repeat with another full node as new secondary
      - **FUTURE:** try to do fork detection from some possibly old
             lightblock in store. (Might be the approach for the
             light node that assumes to be connected to correct
             full nodes only from time to time)

- Expected precondition
  - *FullNodes* is nonempty
- Expected postcondition
  - addr is moved from *Secondaries* to *FaultyNodes*
  - an address *a* is moved from *FullNodes* to *Secondaries*
- Error condition
  - if precondition is violated

### From the verifier

```go
func VerifyToTarget(primary PeerID, lightStore LightStore,
                    targetHeight Height) (LightStore, Result)
```

See the [verification specification][verification] for details.

## Solution

### Shared data of the light client

- a pool of full nodes *FullNodes* that have not been contacted before
- peer set called *Secondaries*
- primary
- lightStore

### Outline

The problem laid out is solved by calling  the function `ForkDetector`
     with a lightstore that contains a light block that has just been
     verified by the verifier.
  
- **TODO:** We should clarify what is the expectation of VerifyToTarget so if it
  returns TimeoutError it can be assumed faulty. I guess that
  VerifyToTarget with correct full node should never terminate with
  TimeoutError.

- **TODO:** clarify EXPIRED case. Can we always punish? Can we give sufficient
  conditions.
  
### Fork Detector

#### **[LCD-FUNC-DETECTOR.1]:**

```go
func ForkDetector(ls LightStore, PoFs PoFStore)
{
 testedLB := LightStore.LatestVerified()
 for i, secondary range Secondaries {
     if OK = CrossCheck(secondary, testedLB) {
   // header matches. we do nothing.
  }
  else {
   // [LCD-REQ-REP]
   // header does not match. there is a situation.
   // we try to verify sh by querying s
   // we set up an auxiliary lightstore with the highest
   // trusted lightblock and the lightblock we want to verify
   auxLS.Init
   auxLS.Update(LightStore.LatestTrusted(), StateVerified);
   auxLS.Update(sh,StateUnverified);
   LS,result := VerifyToTarget(secondary, auxLS, sh.Header.Height)
   if (result = ResultSuccess || result = EXPIRED) {
    // we verified header sh which is conflicting to hd
    // there is a fork on the main blockchain.
    // If return code was EXPIRED it might be too late
    // to punish, we still report it.
    pof = new LightNodeProofOfFork;
    pof.TrustedBlock := LightStore.LatestTrusted()
    pof.PrimaryTrace :=
        LightStore.Subtrace(LightStore.LatestTrusted().Height,
                         testedLB.Height);
    pof.SecondaryTrace :=
        auxLS.Subtrace(LightStore.LatestTrusted().Height,
                    testedLB.Height);
    PoFs.Add(pof);
   }
   else {
    // secondary might be faulty or unreachable
    // it might fail to provide a trace that supports sh
    // or time out
    Replace_Secondary(secondary)
   }
  }
 }
 return PoFs
}
```

**TODO:** formalize conditions

- Expected precondition
  - Secondaries initialized and non-empty
  - `PoFs` initialized and empty
  - *lightStore.LatestTrusted().Height < lightStore.LatestVerified().Height*
- Expected postcondition
  - satisfies [LCD-DIST-INV.1], [LCD-DIST-LIFE-FORK.1]
  - removes faulty secondary if it reports wrong header
  - **TODO** submit proof of fork
- Error condition
  - fails if precondition is violated
  - fails if [LCV-INV-TP] is violated (no trusted header within
      trusting period

----

## Correctness arguments

#### Argument for [LCD-DIST-INV]

**TODO**

#### Argument for [LCD-DIST-LIFE-FORK]

**TODO**

# References

> links to other specifications/ADRs this document refers to

[[verification]] The specification of the light client verification.

[[tendermintfork]] Tendermint fork detection and accountability

[[accountability]] Fork accountability

[TMBC-FM-2THIRDS-linkVDD]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md#**[TMBC-FM-2THIRDS-link]**:

[TMBC-FM-2THIRDS-link]: https://github.com/tendermint/spec/blob/master/spec/consensus/light-client/verification.md

[block]: https://github.com/tendermint/spec/blob/d46cd7f573a2c6a2399fcab2cde981330aa63f37/spec/core/data_structures.md

[blockchain]: https://github.com/informalsystems/VDD/tree/master/blockchain/blockchain.md

[lightclient]: https://github.com/interchainio/tendermint-rs/blob/e2cb9aca0b95430fca2eac154edddc9588038982/docs/architecture/adr-002-lite-client.md

[verificationVDD]: https://github.com/informalsystems/VDD/blob/master/lightclient/failuredetector.md

[verification]: https://github.com/informalsystems/tendermint-rs/blob/master/docs/spec/lightclient/verification.md

[accountability]: https://github.com/tendermint/spec/blob/master/spec/consensus/light-client/accountability.md

[tendermintfork]: https://docs.google.com/document/d/1xjyp5JOPt7QfHem1AFEaowBH2Plk0IHACWtYFXFvO7E/edit#heading=h.th2369ptc2ve
